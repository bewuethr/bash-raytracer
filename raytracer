#!/bin/bash
set -u

# Show usage instructions
show_help () {
cat <<EOF
Usage: ${0##*/} [-hf8] [-v FOV] [-s FACTOR]
Render the Whitted ray tracing scene using terminal escape codes.

    -h         display this help text and exit
    -f         use the full terminal window instead of the standard 104x34
               characters
    -s FACTOR  shrink rendered image by factor FACTOR
    -v FOV     use field of view FOV (in degrees) instead of the default 90
    -8         use 8-bit colours instead of 24-bit colours

The -f and -s options override each other silently; the last one issued is used.
EOF
}

# Global variables
init_globals () {
    # Set defaults
    local fov=90        # Field of view
    local shrinkage=1   # Scaling factor for image size
    bit8=0        # Use 8-bit colours instead of 24-bit colours?

    # Parse command line options
    local opt

    while getopts ":hv:s:f8" opt; do
        case "$opt" in
            h)
                show_help
                exit 0
                ;;
            v)
                fov=$OPTARG
                ;;
            s)
                shrinkage=$OPTARG
                ;;
            f)
                shrinkage='fullscreen'
                ;;
            8)
                bit8=1
                ;;
            \?)
                echo "Invalid option: -$OPTARG" >&2
                show_help >&2
                exit 1
                ;;
            :)
                echo "Option -$OPTARG requires an argument." >&2
                show_help >&2
                exit 1
                ;;
        esac
    done

    # Image dimensions
    if [[ $shrinkage == fullscreen ]]; then
        img_w=$(tput cols)
        img_h=$(tput lines)
    else
        img_w=$(( 104 / shrinkage ))
        img_h=$(( 34 / shrinkage ))
    fi

    # Aspect ratio takes non-square pixel shape into account
    img_ar=$(bc <<< "scale=3; ($img_w / 2) / $img_h")

    # Scale for field of view; pi is 4 * atan(1)
    scale=$(bc -l <<< "scale=3; x = $fov * 2 * a(1) / 180; s(x)/c(x)")

    # Background colour
    bg_col="55 163 212"

    # Reset colour
    reset=$(tput sgr0)

    # Objects
    declare -Ag light0=(
        [col]="255 255 255"
        [dir]="-0.1 0.2 -1"
    )
    declare -Ag obj_sphere0=(
        [origin]="0.2 3 1.1"
        [radius]=1.25
        [col]="147 244 136"
        [intersect]=intersect_sphere
    )
    declare -Ag obj_sphere1=(
        [origin]="-1.5 4 0.3"
        [radius]=1.2
        [col]="161 214 220"
        [intersect]=intersect_sphere
    )
    # Plane is not really used any longer - this is just an example of how to
    # declare one
    # declare -Ag obj_plane0=(
    #     [p0]="0 0 -1.2"
    #     [n]="0 0 1"
    #     [col]=81
    #     [intersect]=intersect_plane
    # )
    declare -Ag obj_triangle0=(
        [p0]="-10 0 -1.2"
        [p1]="2.75 10 -1.2"
        [p2]="-10 10 -1.2"
        [col1]="195 38 0"
        [col2]="248 231 44"
        [intersect]=intersect_triangle
        [pattern]=checker
    )
    declare -Ag obj_triangle1=(
        [p0]="-10 0 -1.2"
        [p1]="2.75 0 -1.2"
        [p2]="2.75 10 -1.2"
        [col1]="195 38 0"
        [col2]="248 231 44"
        [intersect]=intersect_triangle
        [pattern]=checker
    )

    # Add normal to objects, where possible
    # Plane already has it, sphere normal depends on hit point
    local tri_name
    for tri_name in "${!obj_triangle@}"; do
        local -n triangle=$tri_name
        triangle[n]="$(get_tri_normal ${triangle[p0]} ${triangle[p1]} ${triangle[p2]})"
    done

    # Initialize camera-to-world matrix
    declare -Ag cam_to_world
    cam_to_world=(
        [0,0]=1 [0,1]=0  [0,2]=0 [0,3]=0
        [1,0]=0 [1,1]=0  [1,2]=1 [1,3]=0
        [2,0]=0 [2,1]=-1 [2,2]=0 [2,3]=0
        [3,0]=0 [3,1]=0  [3,2]=1 [3,3]=1
    )

    # Ray origin in camera coordinates
    ray_origin=(0 0 0)

    # Normalize light direction vector
    light0[dir]="$(normalize "${light0[dir]}")"
}

# Calculate normal of triangle defined by three points
get_tri_normal () {
    local p0=($1 $2 $3)
    local p1=($4 $5 $6)
    local p2=($7 $8 $9)

    bc bc_lib.bc <<EOF
        scale = 3

        p0[0] = ${p0[0]}
        p0[1] = ${p0[1]}
        p0[2] = ${p0[2]}
        p1[0] = ${p1[0]}
        p1[1] = ${p1[1]}
        p1[2] = ${p1[2]}
        p2[0] = ${p2[0]}
        p2[1] = ${p2[1]}
        p2[2] = ${p2[2]}

        . = vec_diff(p1[], p0[], p0p1[])
        . = vec_diff(p2[], p0[], p0p2[])
        . = cross_prod(p0p1[], p0p2[], n[])
        . = normalize(n[])

        print n[0], " ", n[1], " ", n[2]
EOF
}

# Map single RGB component (0-255) to terminal colour component (0-5)
get_component () {
    local comp=${1%.*}
    echo $(( comp > 115 ? (comp - 116) / 40 + 2 :
             comp > 47  ? 1                     : 0 ))
}

# Map RGB triple to terminal colour
rgb_to_term () {
    local rgbcol=($@)
    local rterm=$(get_component ${rgbcol[0]})
    local gterm=$(get_component ${rgbcol[1]})
    local bterm=$(get_component ${rgbcol[2]})
    echo $(( 16 + 36 * rterm + 6 * gterm + bterm ))
}

# Transform 3D vector with given matrix - assume row vector and v * M
vec_matrix_mult () {
    local v=($1 $2 $3) # The vector
    local -n M=$4      # The matrix
    echo "$(bc <<< "scale=3;
        ${v[0]} * ${M[0,0]} + ${v[1]} * ${M[1,0]} + ${v[2]} * ${M[2,0]} + ${M[3,0]}
        ${v[0]} * ${M[0,1]} + ${v[1]} * ${M[1,1]} + ${v[2]} * ${M[2,1]} + ${M[3,1]}
        ${v[0]} * ${M[0,2]} + ${v[1]} * ${M[1,2]} + ${v[2]} * ${M[2,2]} + ${M[3,2]}")"
}

# Subtract the second vector from the first vector
vec_diff () {
    local v1=($1 $2 $3)
    local v2=($4 $5 $6)
    echo "$(bc <<< "scale=3
        ${v1[0]} - ${v2[0]}
        ${v1[1]} - ${v2[1]}
        ${v1[2]} - ${v2[2]}")"
}

# Transform x,y raster coordinates to camera coordinates
# Image plane is one unit away from camera along negative z-axis
raster_to_camera () {
    local x=$1
    local y=$2

    echo "$(bc <<< "scale=3
        (2 * ($x + 0.5) / $img_w - 1) * $img_ar * $scale
        1 - 2 * ($y + 0.5) / $img_h * $scale")
        -1"
}

# Normalize argument vector to unit length
normalize () {
    local v=($@)
    echo "$(bc <<< "scale=3; len = sqrt(${v[0]}^2 + ${v[1]}^2 + ${v[2]}^2)
        ${v[0]} / len
        ${v[1]} / len
        ${v[2]} / len")"
}

# Intersection functions
# Print distance to origin if ray intersects object and -1 if not
# Arguments: origin and direction of ray, variable name of object

# Ray and sphere
intersect_sphere () {
    local o=($1 $2 $3)
    local d=($4 $5 $6)
    local -n sphere=$7
    local c=(${sphere[origin]})
    local r=${sphere[radius]}

    bc bc_lib.bc <<EOF
        scale = 3

        o[0] = ${o[0]}
        o[1] = ${o[1]}
        o[2] = ${o[2]}
        d[0] = ${d[0]}
        d[1] = ${d[1]}
        d[2] = ${d[2]}
        c[0] = ${c[0]}
        c[1] = ${c[1]}
        c[2] = ${c[2]}
        r    = $r

        a = dot_prod(d[], d[])
        b = 2 * (dot_prod(o[], d[]) - dot_prod(d[], c[]))
        c = dot_prod(o[], o[]) + dot_prod(c[], c[]) - 2 * dot_prod(o[], c[]) - r^2

        discr = b^2 - 4 * a * c

        if (discr < 0) {
            print -1
        } else if (discr == 0) {
            print -b / (2 * a)
        } else {
            t1 = (-b + sqrt(discr)) / (2 * a)
            t2 = (-b - sqrt(discr)) / (2 * a)
            print min(t1, t2)
        }
EOF
}

# Ray and plane
intersect_plane () {
    local o=($1 $2 $3)
    local d=($4 $5 $6)
    local -n plane=$7
    local p0=(${plane[p0]})
    local n=(${plane[n]})

    bc bc_lib.bc <<EOF
        scale = 3

        o[0]  = ${o[0]}
        o[1]  = ${o[1]}
        o[2]  = ${o[2]}
        d[0]  = ${d[0]}
        d[1]  = ${d[1]}
        d[2]  = ${d[2]}
        p0[0] = ${p0[0]}
        p0[1] = ${p0[1]}
        p0[2] = ${p0[2]}
        n[0]  = ${n[0]}
        n[1]  = ${n[1]}
        n[2]  = ${n[2]}

        denom = dot_prod(n[], d[])

        if (abs(denom) > 10^-6) {
            . = vec_diff(p0[], o[], vdif[])
            t = dot_prod(n[], vdif[]) / denom
            if (t >= 0) {
                print t
            } else {
                print -1
            }
        } else {
            print -1
        }
EOF
}

# Ray and triangle
intersect_triangle () {
    local o=($1 $2 $3)
    local d=($4 $5 $6)
    local -n triangle=$7
    local p0=(${triangle[p0]})
    local p1=(${triangle[p1]})
    local p2=(${triangle[p2]})
    local n=(${triangle[n]})

    bc bc_lib.bc <<EOF
        scale = 3

        o[0]  = ${o[0]}
        o[1]  = ${o[1]}
        o[2]  = ${o[2]}
        d[0]  = ${d[0]}
        d[1]  = ${d[1]}
        d[2]  = ${d[2]}
        p0[0] = ${p0[0]}
        p0[1] = ${p0[1]}
        p0[2] = ${p0[2]}
        p1[0] = ${p1[0]}
        p1[1] = ${p1[1]}
        p1[2] = ${p1[2]}
        p2[0] = ${p2[0]}
        p2[1] = ${p2[1]}
        p2[2] = ${p2[2]}
        n[0]  = ${n[0]}
        n[1]  = ${n[1]}
        n[2]  = ${n[2]}


        . = vec_diff(p1[], p0[], p0p1[])
        denom = dot_prod(n[], d[])

        if (abs(denom) > 10^-6) {
            /* There is a ray-plane intersection */
            . = vec_diff(p0[], o[], vdif[])
            t = dot_prod(n[], vdif[]) / denom

            if (t >= 0) {
                /* Test if intersection point p is in triangle */
                for (i = 0; i < 3; ++i)
                    p[i] = o[i] + t * d[i]

                /* First edge */
                . = vec_diff(p[], p0[], p0p[])
                . = cross_prod(p0p1[], p0p[], cp[])
                if (dot_prod(n[], cp[]) < 0)
                    t = -1

                /* Second edge */
                if (t != -1) {
                    . = vec_diff(p2[], p1[], p1p2[])
                    . = vec_diff(p[], p1[], p1p[])
                    . = cross_prod(p1p2[], p1p[], cp[])
                    if (dot_prod(n[], cp[]) < 0)
                        t = -1
                }

                /* Third edge */
                if (t != -1) {
                    . = vec_diff(p0[], p2[], p2p0[])
                    . = vec_diff(p[], p2[], p2p[])
                    . = cross_prod(p2p0[], p2p[], cp[])
                    if (dot_prod(n[], cp[]) < 0)
                        t = -1
                }

                /* The intersection point is within the triangle */
                print t

            } else {
                /* Ray intersects plane behind camera */
                print -1
            }

        } else {
            /* Ray is parallel to triangle plane */
            print -1
        }
EOF
}

# Get normal at sphere hit point
# Arguments: hit point, sphere name
get_sphere_normal () {
    local hit_point=($1 $2 $3)
    local obj_name=$4
    local -n sphere=$obj_name
    local c=(${sphere[origin]})

    bc bc_lib.bc <<EOF
        scale = 3

        p[0]  = ${hit_point[0]}
        p[1]  = ${hit_point[1]}
        p[2]  = ${hit_point[2]}
        c[0]  = ${c[0]}
        c[1]  = ${c[1]}
        c[2]  = ${c[2]}

        . = vec_diff(p[], c[], n[])
        . = normalize(n[])

        print n[0], " ", n[1], " ", n[2]
EOF
}

# Ambient shading with light0 direction and colour from iect; return RGB triple
# Uses 20% of light colour for ambient lighting
shade_ambient () {
    # Make light colour a vector
    local light_col=(${light0[col]})

    # Make hitpoint colour a vector
    local obj_col=(${isect[col]})

    bc bc_lib.bc <<EOF
        scale = 3

        /* Colour of light */
        lr = ${light_col[0]}
        lg = ${light_col[1]}
        lb = ${light_col[2]}

        /* Object colour */
        r = ${obj_col[0]}
        g = ${obj_col[1]}
        b = ${obj_col[2]}

        /* Calculate ambient colour */
        r_res = 0.1 * r / 255 * lr
        g_res = 0.1 * g / 255 * lg
        b_res = 0.1 * b / 255 * lb

        print r_res, " ", g_res, " ", b_res
EOF
}

# Diffuse shading with light0 direction and colour, return RGB triple
# Add diffuse colour to ambient colour
# Arguments: uses all global objects
shade_diffuse () {
    # Make light direction and colour vectors
    local light_dir=(${light0[dir]})
    local light_col=(${light0[col]})

    # Surface normal
    local n=(${isect[n]})

    # Colour at hit point
    local obj_col=(${isect[col]})

    # Ambient colour
    local amb_col=($rgb_colour)

    bc bc_lib.bc <<EOF
        scale = 3

        /* Direction of light (inverted) */
        l[0] = ${light_dir[0]} * -1
        l[1] = ${light_dir[1]} * -1
        l[2] = ${light_dir[2]} * -1

        /* Surface normal */
        n[0] = ${n[0]}
        n[1] = ${n[1]}
        n[2] = ${n[2]}

        /* Colour of light */
        lr = ${light_col[0]}
        lg = ${light_col[1]}
        lb = ${light_col[2]}

        /* Object colour */
        r_obj = ${obj_col[0]}
        g_obj = ${obj_col[1]}
        b_obj = ${obj_col[2]}

        /* Object ambient colour */
        r_amb = ${amb_col[0]}
        g_amb = ${amb_col[1]}
        b_amb = ${amb_col[2]}

        lambert = max(0, dot_prod(l[], n[]))

        /* Calculate resulting colour: ambient plus diffuse */
        r_res = min(r_amb + r_obj/255 * lr * lambert, 255)
        g_res = min(g_amb + g_obj/255 * lg * lambert, 255)
        b_res = min(b_amb + b_obj/255 * lb * lambert, 255)

        print r_res, " ", g_res, " ", b_res
EOF
}

# Tests intersection with objects in scene
# Returns true if ray intersects any object, false if not
# If flag is set, isect is populated with colour of nearest object, hit point and
# normal at hit point
# Arguments: origin and direction of ray; flag to indicate if isect should be populated
trace () {
    local o=($1 $2 $3)
    local d=($4 $5 $6)
    local isect_flag=${7:-}
    local t_min=999999
    local object_name nearest_object_name
    local t
    local retval=1
    for object_name in "${!obj_@}"; do
        local -n object=$object_name
        t=$("${object[intersect]}" "${o[@]}" "${d[@]}" "$object_name")
        if (( $(bc <<< "$t > 0 && $t < $t_min") )); then
            retval=0

            # Do we only need to know if we intersect?
            [[ -z $isect_flag ]] && return 0
            nearest_object_name=$object_name
            t_min=$t
            if [[ ${object[pattern]:-none} == "checker" ]]; then
                if (( $(bc bc_lib.bc <<< "
                    scale = 3
                    x = ${o[0]} + $t * ${d[0]}
                    y = ${o[1]} + $t * ${d[1]}
                    scale = 0
                    (floor(x) + floor(y)) % 2 == 0
                ") )); then
                    isect[col]="${object[col1]}"
                else
                    isect[col]="${object[col2]}"
                fi
            else
                isect[col]="${object[col]}"
            fi
        fi
    done

    # We hit something and have to populate isect
    if (( retval == 0 )); then
        local -n nearest_object=$nearest_object_name

        # Calculate hit point
        isect[hit_point]=$(bc <<< "
            scale = 3
            print ${o[0]} + $t_min * ${d[0]}, \" \"
            print ${o[1]} + $t_min * ${d[1]}, \" \"
            print ${o[2]} + $t_min * ${d[2]}
        ")

        # Get normal at hit point
        case $nearest_object_name in
            *plane* | *triangle*)
                isect[n]=${nearest_object[n]}
                ;;
            *sphere*)
                isect[n]=$(get_sphere_normal ${isect[hit_point]} $nearest_object_name)
                ;;
            *)
                echo "Illegal object name $nearest_object_name" >&2
                ;;
        esac
    fi
    return $retval
}

# Read command line options and initialize global variables
init_globals "$@"

ray_origin_world=($(vec_matrix_mult "${ray_origin[@]}" cam_to_world))

# Global loop
for (( i = 0; i < img_h; ++i )); do
    for (( j = 0; j < img_w; ++j )); do
        declare -A isect=([col]="$bg_col")
        ray_p_cam=($(raster_to_camera $j $i))
        ray_p_world=($(vec_matrix_mult "${ray_p_cam[@]}" cam_to_world))
        ray_direction=($(vec_diff "${ray_p_world[@]}" "${ray_origin_world[@]}"))
        ray_direction=($(normalize "${ray_direction[@]}"))

        # Check ray-object intersection, populate isect
        if trace "${ray_origin_world[@]}" "${ray_direction[@]}" get_isect; then

            # Ray hits an object, shade pixel with ambient shader
            rgb_colour=$(shade_ambient)

            # Calculate shadow ray direction (invert light direction)
            shray_direction=(${light0[dir]})
            shray_direction=($(bc bc_lib.bc <<< "
                scale = 3
                v[0] = ${shray_direction[0]}
                v[1] = ${shray_direction[1]}
                v[2] = ${shray_direction[2]}
                . = invert(v[])
                print v[0], \" \", v[1], \" \", v[2]
            "))

            # Add bias to hitpoint to avoid self-intersection
            hit_point=(${isect[hit_point]})
            n=(${isect[n]})
            bias_hit_point=$(bc <<< "
                scale = 3
                print ${hit_point[0]} + 0.002 * ${n[0]}, \" \"
                print ${hit_point[1]} + 0.002 * ${n[1]}, \" \"
                print ${hit_point[2]} + 0.002 * ${n[2]}
            ")

            # Cast shadow ray, don't populate isect
            if ! trace $bias_hit_point "${shray_direction[@]}"; then
                rgb_colour=$(shade_diffuse)
            fi
        else
            # Ray doesn't hit any object
            rgb_colour=$bg_col
        fi
        colour=$(tput setab $(rgb_to_term "$rgb_colour"))
        printf "%b" "$colour $reset"
    done
    echo
done
