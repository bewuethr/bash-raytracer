#!/bin/bash
set -u

# Global variables
init_globals () {
    # Field of view in degrees, default to 90
    local fov=${1:-90}
    local shrinkage=$2

    # Image dimensions
	if [[ $shrinkage == fs ]]; then
		img_w=$COLUMNS
		img_h=$LINES
	else
		img_w=$(( 90 / shrinkage ))
		img_h=$(( 36 / shrinkage ))
	fi

    # Aspect ratio takes non-square pixel shape into account
    img_ar=$(bc <<< "scale=3; ($img_w / 2) / $img_h")

    # Scale for field of view; pi is 4 * atan(1)
    scale=$(bc -l <<< "scale=3; x = $fov * 2 * a(1) / 180; s(x)/c(x)")

    # Background colour
    bg_col=$(rgb_to_term 55 163 212)

    # Reset colour
    reset=$(tput sgr0)

    # Objects
    declare -Ag obj_sphere0=(
        [origin]="0.2 3 1.1"
        [radius]=1.25
        [col]="147 244 136"
        [intersect]=intersect_sphere
    )
    declare -Ag obj_sphere1=(
        [origin]="-1.5 4 0.3"
        [radius]=1.2
        [col]="161 214 220"
        [intersect]=intersect_sphere
    )
    # Plane is not really used any longer - this is just an example of how to
    # declare one
    # declare -Ag obj_plane0=(
    #     [p0]="0 0 -1.2"
    #     [n]="0 0 1"
    #     [col]=81
    #     [intersect]=intersect_plane
    # )
    declare -Ag obj_triangle0=(
        [p0]="-10 0 -1.2"
        [p1]="2.75 10 -1.2"
        [p2]="-10 10 -1.2"
        [col1]="195 38 0"
        [col2]="248 231 44"
        [intersect]=intersect_triangle
        [pattern]=checker
    )
    declare -Ag obj_triangle1=(
        [p0]="-10 0 -1.2"
        [p1]="2.75 0 -1.2"
        [p2]="2.75 10 -1.2"
        [col1]="195 38 0"
        [col2]="248 231 44"
        [intersect]=intersect_triangle
        [pattern]=checker
    )

    # Add normal to objects, where possible
    # Plane already has it, sphere normal depends on hit point
    local tri_name
    for tri_name in "${!obj_triangle@}"; do
        local -n triangle=$tri_name
        triangle[n]="$(get_tri_normal ${triangle[p0]} ${triangle[p1]} ${triangle[p2]})"
    done

    # Initialize camera-to-world matrix
    declare -Ag cam_to_world
    cam_to_world=(
        [0,0]=1 [0,1]=0  [0,2]=0 [0,3]=0
        [1,0]=0 [1,1]=0  [1,2]=1 [1,3]=0
        [2,0]=0 [2,1]=-1 [2,2]=0 [2,3]=0
        [3,0]=0 [3,1]=0  [3,2]=1 [3,3]=1
    )

    # Ray origin in camera coordinates
    ray_origin=(0 0 0)
}

# Calculate normal of triangle defined by three points
get_tri_normal () {
    local p0=($1 $2 $3)
    local p1=($4 $5 $6)
    local p2=($7 $8 $9)

    bc bc_lib.bc <<EOF
        scale = 3

        p0[0] = ${p0[0]}
        p0[1] = ${p0[1]}
        p0[2] = ${p0[2]}
        p1[0] = ${p1[0]}
        p1[1] = ${p1[1]}
        p1[2] = ${p1[2]}
        p2[0] = ${p2[0]}
        p2[1] = ${p2[1]}
        p2[2] = ${p2[2]}

        . = vec_diff(p1[], p0[], p0p1[])
        . = vec_diff(p2[], p0[], p0p2[])
        . = cross_prod(p0p1[], p0p2[], n[])
        . = normalize(n[])

        print n[0], " ", n[1], " ", n[2]
EOF
}

# Map single RGB component (0-255) to terminal colour component (0-5)
get_component () {
    local comp=${1%.*}
    echo $(( comp > 115 ? (comp - 116) / 40 + 2 :
             comp > 47  ? 1                     : 0 ))
}

# Map RGB triple to terminal colour
rgb_to_term () {
    local rgbcol=($@)
    local rterm=$(get_component ${rgbcol[0]})
    local gterm=$(get_component ${rgbcol[1]})
    local bterm=$(get_component ${rgbcol[2]})
    echo $(( 16 + 36 * rterm + 6 * gterm + bterm ))
}

# Transform 3D vector with given matrix - assume row vector and v * M
vec_matrix_mult () {
    local v=($1 $2 $3) # The vector
    local -n M=$4      # The matrix
    echo "$(bc <<< "scale=3;
        ${v[0]} * ${M[0,0]} + ${v[1]} * ${M[1,0]} + ${v[2]} * ${M[2,0]} + ${M[3,0]}
        ${v[0]} * ${M[0,1]} + ${v[1]} * ${M[1,1]} + ${v[2]} * ${M[2,1]} + ${M[3,1]}
        ${v[0]} * ${M[0,2]} + ${v[1]} * ${M[1,2]} + ${v[2]} * ${M[2,2]} + ${M[3,2]}")"
}

# Subtract the second vector from the first vector
vec_diff () {
    local v1=($1 $2 $3)
    local v2=($4 $5 $6)
    echo "$(bc <<< "scale=3
        ${v1[0]} - ${v2[0]}
        ${v1[1]} - ${v2[1]}
        ${v1[2]} - ${v2[2]}")"
}

# Transform x,y raster coordinates to camera coordinates
# Image plane is one unit away from camera along negative z-axis
raster_to_camera () {
    local x=$1
    local y=$2

    echo "$(bc <<< "scale=3
        (2 * ($x + 0.5) / $img_w - 1) * $img_ar * $scale
        1 - 2 * ($y + 0.5) / $img_h * $scale")
        -1"
}

# Normalize argument vector to unit length
normalize () {
    local v=($@)
    echo "$(bc <<< "scale=3; len = sqrt(${v[0]}^2 + ${v[1]}^2 + ${v[2]}^2)
        ${v[0]} / len
        ${v[1]} / len
        ${v[2]} / len")"
}

# Intersection functions
# Arguments: origin and direction of ray, variable name of object
# Prints distance to origin if ray intersects object and -1 if not

# Ray and sphere
intersect_sphere () {
    local o=($1 $2 $3)
    local d=($4 $5 $6)
    local -n sphere=$7
    local c=(${sphere[origin]})
    local r=${sphere[radius]}

    bc bc_lib.bc <<EOF
        scale = 3

        o[0] = ${o[0]}
        o[1] = ${o[1]}
        o[2] = ${o[2]}
        d[0] = ${d[0]}
        d[1] = ${d[1]}
        d[2] = ${d[2]}
        c[0] = ${c[0]}
        c[1] = ${c[1]}
        c[2] = ${c[2]}
        r    = $r

        a = dot_prod(d[], d[])
        b = 2 * (dot_prod(o[], d[]) - dot_prod(d[], c[]))
        c = dot_prod(o[], o[]) + dot_prod(c[], c[]) - 2 * dot_prod(o[], c[]) - r^2

        discr = b^2 - 4 * a * c

        if (discr < 0) {
            print -1
        } else if (discr == 0) {
            print -b / (2 * a)
        } else {
            t1 = (-b + sqrt(discr)) / (2 * a)
            t2 = (-b - sqrt(discr)) / (2 * a)
            print min(t1, t2)
        }
EOF
}

# Ray and plane
intersect_plane () {
    local o=($1 $2 $3)
    local d=($4 $5 $6)
    local -n plane=$7
    local p0=(${plane[p0]})
    local n=(${plane[n]})

    bc bc_lib.bc <<EOF
        scale = 3

        o[0]  = ${o[0]}
        o[1]  = ${o[1]}
        o[2]  = ${o[2]}
        d[0]  = ${d[0]}
        d[1]  = ${d[1]}
        d[2]  = ${d[2]}
        p0[0] = ${p0[0]}
        p0[1] = ${p0[1]}
        p0[2] = ${p0[2]}
        n[0]  = ${n[0]}
        n[1]  = ${n[1]}
        n[2]  = ${n[2]}

        denom = dot_prod(n[], d[])

        if (abs(denom) > 10^-6) {
            . = vec_diff(p0[], o[], vdif[])
            t = dot_prod(n[], vdif[]) / denom
            if (t >= 0) {
                print t
            } else {
                print -1
            }
        } else {
            print -1
        }
EOF
}

# Ray and triangle
intersect_triangle () {
    local o=($1 $2 $3)
    local d=($4 $5 $6)
    local -n triangle=$7
    local p0=(${triangle[p0]})
    local p1=(${triangle[p1]})
    local p2=(${triangle[p2]})
    local n=(${triangle[n]})

    bc bc_lib.bc <<EOF
        scale = 3

        o[0]  = ${o[0]}
        o[1]  = ${o[1]}
        o[2]  = ${o[2]}
        d[0]  = ${d[0]}
        d[1]  = ${d[1]}
        d[2]  = ${d[2]}
        p0[0] = ${p0[0]}
        p0[1] = ${p0[1]}
        p0[2] = ${p0[2]}
        p1[0] = ${p1[0]}
        p1[1] = ${p1[1]}
        p1[2] = ${p1[2]}
        p2[0] = ${p2[0]}
        p2[1] = ${p2[1]}
        p2[2] = ${p2[2]}
        n[0]  = ${n[0]}
        n[1]  = ${n[1]}
        n[2]  = ${n[2]}


        . = vec_diff(p1[], p0[], p0p1[])
        denom = dot_prod(n[], d[])

        if (abs(denom) > 10^-6) {
            /* There is a ray-plane intersection */
            . = vec_diff(p0[], o[], vdif[])
            t = dot_prod(n[], vdif[]) / denom

            if (t >= 0) {
                /* Test if intersection point p is in triangle */
                for (i = 0; i < 3; ++i)
                    p[i] = o[i] + t * d[i]

                /* First edge */
                . = vec_diff(p[], p0[], p0p[])
                . = cross_prod(p0p1[], p0p[], cp[])
                if (dot_prod(n[], cp[]) < 0)
                    t = -1

                /* Second edge */
                if (t != -1) {
                    . = vec_diff(p2[], p1[], p1p2[])
                    . = vec_diff(p[], p1[], p1p[])
                    . = cross_prod(p1p2[], p1p[], cp[])
                    if (dot_prod(n[], cp[]) < 0)
                        t = -1
                }

                /* Third edge */
                if (t != -1) {
                    . = vec_diff(p0[], p2[], p2p0[])
                    . = vec_diff(p[], p2[], p2p[])
                    . = cross_prod(p2p0[], p2p[], cp[])
                    if (dot_prod(n[], cp[]) < 0)
                        t = -1
                }

                /* The intersection point is within the triangle */
                print t

            } else {
                /* Ray intersects plane behind camera */
                print -1
            }

        } else {
            /* Ray is parallel to triangle plane */
            print -1
        }
EOF
}

#Arguments: origin, direction, distance, sphere name
# Get normal at sphere hit point
get_sphere_normal () {
    local o=($1 $2 $3)
    local d=($4 $5 $6)
    local t=$7
    local obj_name=$8
    local -n sphere=$obj_name
    local c=(${sphere[origin]})

    bc bc_lib.bc <<EOF
        scale = 3

        o[0]  = ${o[0]}
        o[1]  = ${o[1]}
        o[2]  = ${o[2]}
        d[0]  = ${d[0]}
        d[1]  = ${d[1]}
        d[2]  = ${d[2]}
        t     = $t
        c[0]  = ${c[0]}
        c[1]  = ${c[1]}
        c[2]  = ${c[2]}

        for (i = 0; i < 3; ++i)
            p[i] = o[i] + t * d[i]

        . = vec_diff(p[], c[], n[])
        . = normalize(n[])

        print n[0], " ", n[1], " ", n[2]
EOF
}

# Arguments: origin, direction, distance, object name, object colour
# Shade by incident angle, return RGB triple
shade_incident () {
    local o=($1 $2 $3)
    local d=($4 $5 $6)
    local t=$7
    local obj_name=$8
    local obj_col=($9 ${10} ${11})

    local -n object=$obj_name

    # Get normal at hit point
    local n
    case $obj_name in
        *plane* | *triangle*)
            n=(${object[n]})
            ;;
        *sphere*)
            n=($(get_sphere_normal "${o[@]}" "${d[@]}" $t $obj_name))
            ;;
        *)
            echo "Illegal object name $obj_name" >&2
            ;;
    esac

    bc bc_lib.bc <<EOF
        /* Calculate facing ratio */
        d[0]  = ${d[0]} * -1
        d[1]  = ${d[1]} * -1
        d[2]  = ${d[2]} * -1
        n[0]  = ${n[0]}
        n[1]  = ${n[1]}
        n[2]  = ${n[2]}

        fac_ratio = max(0, dot_prod(d[], n[]))

        /* Darken colour */
        r = ${obj_col[0]}
        g = ${obj_col[1]}
        b = ${obj_col[2]}

        print fac_ratio * r, " ", fac_ratio * g, " ", fac_ratio * b
EOF
}

# Arguments: origin and direction of ray
# Tests intersection with objects in scene
# Prints colour of object if the ray intersects, background colour if not
trace () {
    local o=($1 $2 $3)
    local d=($4 $5 $6)
    local t_min=999999
    local object_name
    local t
    local col
    for object_name in "${!obj_@}"; do
        local -n object=$object_name
        t=$("${object[intersect]}" "${o[@]}" "${d[@]}" "$object_name")
        if (( $(bc <<< "$t > 0 && $t < $t_min") )); then
            t_min=$t
            if [[ ${object[pattern]:-none} == "checker" ]]; then
                if (( $(bc bc_lib.bc <<< "
                    scale = 3
                    x = ${o[0]} + $t * ${d[0]}
                    y = ${o[1]} + $t * ${d[1]}
                    scale = 0
                    (floor(x) + floor(y)) % 2 == 0
                ") )); then
                    col=(${object[col1]})
                else
                    col=(${object[col2]})
                fi
            else
                col=(${object[col]})
            fi
            col=($(shade_incident "${o[@]}" "${d[@]}" $t $object_name "${col[@]}"))
            col=$(rgb_to_term "${col[@]}")
        fi
    done
    echo "${col:-$bg_col}"
}

# Initialize global variables with field of view and factor by which output should be shrunk
init_globals 90 ${1:-1}

ray_origin_world=($(vec_matrix_mult "${ray_origin[@]}" cam_to_world))

for (( i = 0; i < img_h; ++i )); do
    for (( j = 0; j < img_w; ++j )); do
        ray_p_cam=($(raster_to_camera $j $i))
        ray_p_world=($(vec_matrix_mult "${ray_p_cam[@]}" cam_to_world))
        ray_direction=($(vec_diff "${ray_p_world[@]}" "${ray_origin_world[@]}"))
        ray_direction=($(normalize "${ray_direction[@]}"))
        colour=$(trace "${ray_origin_world[@]}" "${ray_direction[@]}")
        colour=$(tput setab $colour)
        printf "%b" "$colour $reset"
    done
    echo
done
