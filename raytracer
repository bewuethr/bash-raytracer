#!/bin/bash
set -u

# Global variables
init_globals () {
    # Field of view in degrees, default to 90
    local fov=${1:-90}

    # Image dimensions
    img_w=$(tput cols)
    img_h=$(tput lines)

    # Aspect ratio takes non-square pixel shape into account
    img_ar=$(bc <<< "scale=3; ($img_w / 2) / $img_h")

    # Scale for field of view; pi is 4 * atan(1)
    scale=$(bc -l <<< "scale=3; x = $fov * 2 * a(1) / 180; s(x)/c(x)")

    # Background colour
    bg_col=38

    # Reset colour
    reset=$(tput sgr0)

    # Objects
    declare -Ag obj_sphere0=(
        [origin]="0.2 3 1.1"
        [radius]=1.25
        [col]=196
        [intersect]=intersect_sphere
    )
    declare -Ag obj_sphere1=(
        [origin]="-1.5 4 0.3"
        [radius]=1.2
        [col]=81
        [intersect]=intersect_sphere
    )
    declare -Ag obj_plane0=(
        [p0]="0 0 -1.2"
        [n]="0 0 1"
        [col]=226
        [intersect]=intersect_plane
    )

    # Initialize camera-to-world matrix
    declare -Ag cam_to_world
    cam_to_world=(
        [0,0]=1 [0,1]=0  [0,2]=0 [0,3]=0
        [1,0]=0 [1,1]=0  [1,2]=1 [1,3]=0
        [2,0]=0 [2,1]=-1 [2,2]=0 [2,3]=0
        [3,0]=0 [3,1]=0  [3,2]=1 [3,3]=1
    )

    # Ray origin in camera coordinates
    ray_origin=(0 0 0)
}

# Transform 3D vector with given matrix - assume row vector and v * M
vec_matrix_mult () {
    local v=($1 $2 $3) # The vector
    local -n M=$4      # The matrix
    echo "$(bc <<< "scale=3;
        ${v[0]} * ${M[0,0]} + ${v[1]} * ${M[1,0]} + ${v[2]} * ${M[2,0]} + ${M[3,0]};
        ${v[0]} * ${M[0,1]} + ${v[1]} * ${M[1,1]} + ${v[2]} * ${M[2,1]} + ${M[3,1]};
        ${v[0]} * ${M[0,2]} + ${v[1]} * ${M[1,2]} + ${v[2]} * ${M[2,2]} + ${M[3,2]}")"
}

# Subtract the second vector from the first vector
vec_diff () {
    local v1=($1 $2 $3)
    local v2=($4 $5 $6)
    echo "$(bc <<< "scale=3;
        ${v1[0]} - ${v2[0]};
        ${v1[1]} - ${v2[1]};
        ${v1[2]} - ${v2[2]}")"
}

# Transform x,y raster coordinates to camera coordinates
# Image plane is one unit away from camera along negative z-axis
raster_to_camera () {
    local x=$1
    local y=$2

    echo "$(bc <<< "scale=3;
        (2 * ($x + 0.5) / $img_w - 1) * $img_ar * $scale;
        1 - 2 * ($y + 0.5) / $img_h * $scale")
        -1"
}

# Normalize argument vector to unit length
normalize () {
    local v=($@)
    echo "$(bc <<< "scale=3; len = sqrt(${v[0]}^2 + ${v[1]}^2 + ${v[2]}^2);
        ${v[0]} / len;
        ${v[1]} / len;
        ${v[2]} / len")"
}

# Intersection functions
# Arguments: origin and direction of ray, variable name of object
# Prints distance to origin if ray intersects object and -1 if not

# Ray and sphere
intersect_sphere () {
    local o=($1 $2 $3)
    local d=($4 $5 $6)
    local -n sphere=$7
    local c=(${sphere[origin]})
    local r=${sphere[radius]}

    bc bc_lib.bc <<EOF
        scale = 3

        o[0] = ${o[0]}
        o[1] = ${o[1]}
        o[2] = ${o[2]}
        d[0] = ${d[0]}
        d[1] = ${d[1]}
        d[2] = ${d[2]}
        c[0] = ${c[0]}
        c[1] = ${c[1]}
        c[2] = ${c[2]}
        r    = $r

        a = dot_prod(d[], d[])
        b = 2 * (dot_prod(o[], d[]) - dot_prod(d[], c[]))
        c = dot_prod(o[], o[]) + dot_prod(c[], c[]) - 2 * dot_prod(o[], c[]) - r^2

        discr = b^2 - 4 * a * c

        if (discr < 0) {
            print -1
        } else if (discr == 0) {
            print -b / (2 * a)
        } else {
            t1 = (-b + sqrt(discr)) / (2 * a)
            t2 = (-b - sqrt(discr)) / (2 * a)
            if (t1 < t2) {
                print t1
            } else {
                print t2
            }
        }
EOF
}

# Ray and plane
intersect_plane () {
    local o=($1 $2 $3)
    local d=($4 $5 $6)
    local -n plane=$7
    local p0=(${plane[p0]})
    local n=(${plane[n]})

    bc bc_lib.bc <<EOF
        scale = 3

        o[0]  = ${o[0]}
        o[1]  = ${o[1]}
        o[2]  = ${o[2]}
        d[0]  = ${d[0]}
        d[1]  = ${d[1]}
        d[2]  = ${d[2]}
        p0[0] = ${p0[0]}
        p0[1] = ${p0[1]}
        p0[2] = ${p0[2]}
        n[0]  = ${n[0]}
        n[1]  = ${n[1]}
        n[2]  = ${n[2]}

        denom = dot_prod(n[], d[])

        if (abs(denom) > 10^-6) {
            for (i = 0; i < 3; ++i)
                vdif[i] = p0[i] - o[i]
            t = dot_prod(n[], vdif[]) / dot_prod(d[], n[])
            if (t >= 0) {
                print t
            } else {
                print -1
            }
        } else {
            print -1
        }
EOF
}

# Arguments: origin and direction of ray
# Tests intersection with objects in scene
# Prints colour of object if the ray intersects, background colour if not
trace () {
    local o=($1 $2 $3)
    local d=($4 $5 $6)
    local t_min=999999
    local object_name
    local t
    local col
    for object_name in "${!obj_@}"; do
        local -n object=$object_name
        t=$("${object[intersect]}" "${o[@]}" "${d[@]}" "$object_name")
        if (( $(bc <<< "$t > 0 && $t < $t_min") )); then
            t_min=$t
            col=${object[col]}
        fi
    done

    echo "${col:-$bg_col}"
}

# Initialize global variables with field of view
init_globals 90

ray_origin_world=($(vec_matrix_mult "${ray_origin[@]}" cam_to_world))

for (( i = 0; i < img_h; ++i )); do
    for (( j = 0; j < img_w; ++j )); do
        ray_p_cam=($(raster_to_camera $j $i))
        ray_p_world=($(vec_matrix_mult "${ray_p_cam[@]}" cam_to_world))
        ray_direction=($(vec_diff "${ray_p_world[@]}" "${ray_origin_world[@]}"))
        ray_direction=($(normalize "${ray_direction[@]}"))
        colour=$(trace "${ray_origin_world[@]}" "${ray_direction[@]}")
        colour=$(tput setab $colour)
        printf "%b" "$colour $reset"
    done
    echo
done
